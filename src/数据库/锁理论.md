# 锁理论

锁策略（思想）：乐观锁、悲观锁

- 乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做

  适用于读多写少，因为如果出现大量的写操作，写冲突的可能性就会增大，业务层需要不断重试，会大大降低系统性能

  一般使用数据版本（Version）记录机制实现

  悲观锁，正如其名，具有强烈的独占和排他特性，每次去拿数据的时候都认为别人会修改，对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。

  适用于并发量不大、写入操作比较频繁、数据一致性比较高的场景。

  在MySQL中使用悲观锁，必须关闭MySQL的自动提交，set autocommit=0。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。

- 乐观锁是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都**没有对数据库进行加锁**；
- 悲观锁就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；

快照读、当前读

```
select * from table where id = ?;
```



MySQL普通查询是不加锁的，此时是快照读

在末尾加上 `lock in share mode` 时会添加共享锁，在SQL末尾加上 `for update` 会添排他锁，此时是当前读

```
select * from table where id = ? lock in share mode;
select * from table where id = ? for update;
```





串行化隔离级别下，所有查询默认添加 `in share mode`



共享锁、读锁、S锁

排他锁、写锁、X锁



乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。



InnoDB的行锁是对索引进行加锁的，所以搜索条件有且只有索引条件时，才会使用行锁



InnoDB的表锁，本质是Next-Key Locks，只是其范围包含了整个表



InnoDB在RU和RC隔离级别没有使用间隙锁，只有在RR和串行化隔离级别下才使用间隙锁



锁定读、非锁定读



# Java

synchronized 中的无锁、偏向锁、轻量级锁、重量级锁

volatile 

可重入锁 & 不可重入锁

公平锁 & 非公平锁

阻塞 & 非阻塞

